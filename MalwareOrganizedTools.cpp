//
// Created by rojas on 15/03/17.
//

#include "MalwareOrganizedTools.h"

int MalwareOrganizedTools::update_generated_assembly_code(std::string generated_folder_addr) {

    DIR *dir;
    struct dirent *ent;
    if ((dir = opendir (generated_r4_folder.c_str())) != NULL) {
        while ((ent = readdir (dir)) != NULL) {

            if(strcmp(ent->d_name,".") !=0 && strcmp(ent->d_name,"..") != 0) {

                    std::string md5 = ent->d_name;
                    std::string exec_code_and_entry_point_addr = generated_folder_addr + md5+ "/exec_code_and_entry_point/";
                    std::string asm_code_files_root = generated_folder_addr + md5 + "/assembly_code/";

                    Aux::mkdir(asm_code_files_root);

                    DIR *innerdir;
                    struct dirent *innerent;

                    if ((innerdir = opendir (exec_code_and_entry_point_addr.c_str())) != NULL) {
                        while ((innerent = readdir (innerdir)) != NULL) {

                            if(strcmp(innerent->d_name,".") !=0 && strcmp(innerent->d_name,"..") != 0) {


                                std::string file_name = innerent->d_name;
                                std::string file_addr = exec_code_and_entry_point_addr + file_name;
                                std::string asm_file_o = asm_code_files_root + file_name;
                                std::pair<std::string, std::string> ep_and_code = Disassembler::getEntryPointAndAssemblyFromCustomFile(file_addr);

                                std::shared_ptr<DisassemblingInfo> dis_info= Disassembler::dissasemble(ep_and_code.second, file_name,
                                                                                                       ep_and_code.first);

                                Disassembler::write_asm_to_file(asm_file_o, dis_info);
                            }
                        }
                        closedir (innerdir);
                    } else {
                        /* could not open directory */
                        perror ("Couldnt open dir");
                        return EXIT_FAILURE;
                    }
            }
        }
        closedir (dir);
    } else {
        /* could not open directory */
        perror ("Couldnt open dir");
        return EXIT_FAILURE;
    }
    return 0;

}

MalwareOrganizedTools::MalwareOrganizedTools(std::string malware_organized_root) {

    this->seeds_root = malware_organized_root + "seeds/";
    this->malware_organized_root = malware_organized_root;
    this->generated_r4_folder = malware_organized_root + "r4_generated/";
    this->generated_cp_folder = malware_organized_root + "code_pervertor_generated/";
    this->seeds_cfg_folder = this->seeds_root + DEFAULT_CFG_FOLDER + "/";
    this->seeds_exec_code_and_entry_point_folder = this->seeds_root + DEFAULT_NAME_OF_EXEC_CODE_AND_ENTRY_POINT_FOLDER + "/";

}

int MalwareOrganizedTools::update_seeds_assembly_code() {

    DIR *innerdir;
    struct dirent *innerent;

    if ((innerdir = opendir(seeds_exec_code_and_entry_point_folder.c_str())) != NULL) {
        while ((innerent = readdir(innerdir)) != NULL) {

            if (strcmp(innerent->d_name, ".") != 0 && strcmp(innerent->d_name, "..") != 0) {


                std::string file_name = innerent->d_name;
                std::string file_addr = seeds_exec_code_and_entry_point_folder + file_name;
                std::string asm_file_o = seeds_asm_folder + file_name;
                std::pair<std::string, std::string> ep_and_code = Disassembler::getEntryPointAndAssemblyFromCustomFile(
                        file_addr);

                std::shared_ptr<DisassemblingInfo> dis_info = Disassembler::dissasemble(ep_and_code.second, file_name,
                                                                                        ep_and_code.first);

                Disassembler::write_asm_to_file(asm_file_o, dis_info);
            }
        }
        closedir(innerdir);
    } else {
        /* could not open directory */
        perror("Couldnt open dir");
        return EXIT_FAILURE;
    }
    return 0;
}

int MalwareOrganizedTools::update_seeds_cfg(){

    DIR *innerdir;
    struct dirent *innerent;

    Aux::mkdir(seeds_cfg_folder);


    if ((innerdir = opendir(seeds_exec_code_and_entry_point_folder.c_str())) != NULL) {
        while ((innerent = readdir(innerdir)) != NULL) {

            if (strcmp(innerent->d_name, ".") != 0 && strcmp(innerent->d_name, "..") != 0) {

                std::string file_name = innerent->d_name;
                std::string file_addr = seeds_exec_code_and_entry_point_folder + file_name;
                std::string cfg_folder = seeds_cfg_folder + file_name + "/";


                Aux::mkdir(cfg_folder);

                std::string cfg_graphiz_folder = cfg_folder + "graphviz/";
                std::string cfg_json_folder = cfg_folder + "json/";

                Aux::mkdir(cfg_graphiz_folder);
                Aux::mkdir(cfg_json_folder);

                std::string cfg_graphviz_file = cfg_graphiz_folder + file_name + "_cfg.dot";
                std::string cfg_json_file = cfg_json_folder + file_name + "_cfg.json";


                std::pair<std::string, std::string> ep_and_code = Disassembler::getEntryPointAndAssemblyFromCustomFile(
                        file_addr);

                std::shared_ptr<DisassemblingInfo> dis_info = Disassembler::dissasemble(ep_and_code.second, file_name,
                                                                                        ep_and_code.first);

                std::shared_ptr<CustomCFGImpl> cfg_macro = Disassembler::get_cfg(dis_info);

                cfg_macro->write_graphiz(cfg_graphviz_file);


                cfg_macro->serialize(cfg_json_file);

            }
        }
        closedir(innerdir);
    } else {
        /* could not open directory */
        std::string msg = "Couldnt open dir " + seeds_exec_code_and_entry_point_folder;
        perror(msg.c_str());
        return EXIT_FAILURE;
    }
    return 0;
}